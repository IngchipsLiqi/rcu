
/*
** COPYRIGHT (c) 2023 by INGCHIPS
*/

#include <stdio.h>
#include <string.h>

#include "ingsoc.h"
#include "platform_api.h"
#include "profile.h"

#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"
#include "semphr.h"

#include "gap.h"
#include "btstack_event.h"

#include "low_power.h"
#include "key_board.h"

#if defined __cplusplus
    extern "C" {
#endif

static TimerHandle_t enter_low_power_timer = 0;
uint8_t g_exit_saving = 0;
uint16_t g_connection_interval = 0;

#define RAMFUNC __attribute__ ((section (".ramfunc")))
//#define RAMFUNC

#define PRINT_PORT    APB_UART0
RAMFUNC uint32_t cb_putc(char *c, void *dummy)
{
    while (apUART_Check_TXFIFO_FULL(PRINT_PORT) == 1);
    UART_SendData(PRINT_PORT, (uint8_t)*c);
    return 0;
}

RAMFUNC int fputc(int ch, FILE *f)
{
    cb_putc((char *)&ch, NULL);
    return ch;
}

RAMFUNC static void m_apUART_BaudRateSet(UART_TypeDef* pBase, uint32_t ClockFrequency, uint32_t BaudRate)
{
    uint32_t BaudRateDiv;
    uint32_t BaudIntDiv;
    uint32_t BaudFracDiv;

    BaudRateDiv = (ClockFrequency << 3) / BaudRate;


    /* Calculate integer baud rate register value */
    BaudIntDiv = BaudRateDiv / 128;

    /* Calculate fraction baud rate register value */
    BaudRateDiv -= (BaudIntDiv << 7);
    BaudFracDiv =  (BaudRateDiv + 1) / 2;


    pBase->IntBaudDivisor   = BaudIntDiv;

    if (( BaudIntDiv > 65535 ) || ( BaudIntDiv == 0 ))
        for (;;);

    /* Calculate fractional baud rate register value */
    if ( BaudIntDiv == 65535 )
    {
        pBase->FractBaudDivisor = 0;
    }
    else
    {
        BaudRateDiv -= BaudIntDiv;
        pBase->FractBaudDivisor = BaudFracDiv;
    }

    //--------------------------
    // USER NOTE :
    //
    // ARM UART TRM Page 60 -
    //    The UARTLCR_H, UARTIBRD, and UARTFBRD registers form the single 30-bit
    //    wide UARTLCR Register that is updated on a single write strobe generated by a
    //    UARTLCR_H write. So, to internally update the contents of UARTIBRD or
    //    UARTFBRD, a UARTLCR_H write must always be performed at the end.
    //
    pBase->LineCon_H = pBase->LineCon_H;
}

RAMFUNC static void m_apUART_Initialize (UART_TypeDef* pBase, UART_sStateStruct* UARTx, uint32_t IntMask)
{
    // clear Control Register, UARTCR
    pBase->Control = 0;
    // clear all interrupt
    pBase->IntClear = 0;
    // clear all interrupt mask bit
    pBase->IntMask = 0;
    // clear Receive Status Register/Error Clear Register, UARTRSR/UARTECR
    pBase->StatusClear = 0;
    // clear Integer Baud Rate Register, UARTIBRD
    pBase->IntBaudDivisor = 0;
    // clear Fractional Baud Rate Register, UARTFBRD
    pBase->FractBaudDivisor = 0;
    // clear Line Control Register, UARTLCR_H
    pBase->LineCon_H = 0;
    // set BaudDivisor
    m_apUART_BaudRateSet(pBase, UARTx->ClockFrequency, UARTx->BaudRate);
    // set Line Control Register, UARTLCR_H
    pBase->LineCon_H = ( ((UARTx->parity >> 2) & 1) << bsUART_STICK_PARITY ) |  // SPS
                     (   UARTx->word_length       << bsUART_WORD_LENGTH  ) |  // WLEN
                     (   UARTx->fifo_enable       << bsUART_FIFO_ENABLE  ) |  // FEN
                     (   UARTx->two_stop_bits     << bsUART_TWO_STOP_BITS) |  // STP2
                     ( ( UARTx->parity       & 3) << bsUART_PARITY_SELECT) ;  // EPS, EPN

    // set Interrupt FIFO Level Select Register, UARTIFLS
    pBase->FifoSelect = (UARTx->txfifo_waterlevel << bsUART_TRANS_INT_LEVEL ) | // TXIFLSEL
                      (UARTx->rxfifo_waterlevel << bsUART_RECV_INT_LEVEL  ) ; // RXIFLSEL

    /* Empty the receive FIFO */

    //    set all interrupt mask bit
    pBase->IntMask = IntMask;

    // set Control Register, UARTCR, at last
    pBase->Control = UARTx->receive_en  << bsUART_RECEIVE_ENABLE |
                    UARTx->transmit_en << bsUART_TRANSMIT_ENABLE |
                    UARTx->UART_en     << bsUART_ENABLE          |
                    UARTx->cts_en      << bsUART_CTS_ENA         |
                    UARTx->rts_en      << bsUART_RTS_ENA;

}

RAMFUNC static void m_config_uart(uint32_t freq, uint32_t baud)
{
    UART_sStateStruct config;

    config.word_length       = UART_WLEN_8_BITS;
    config.parity            = UART_PARITY_NOT_CHECK;
    config.fifo_enable       = 1;
    config.two_stop_bits     = 0;
    config.receive_en        = 1;
    config.transmit_en       = 1;
    config.UART_en           = 1;
    config.cts_en            = 0;
    config.rts_en            = 0;
    config.rxfifo_waterlevel = 1;
    config.txfifo_waterlevel = 1;
    config.ClockFrequency    = freq;
    config.BaudRate          = baud;

    m_apUART_Initialize(PRINT_PORT, &config, 0);
}

RAMFUNC static void m_set_reg_bit(volatile uint32_t *reg, uint8_t v, uint8_t bit_offset)
{
    uint32_t mask = 1 << bit_offset;
    *reg = (*reg & ~mask) | (v << bit_offset);
}

RAMFUNC void m_send_char(uint8_t c)
{
    while (((PRINT_PORT->Flag >> bsUART_TRANSMIT_FULL) & BW2M(bwUART_TRANSMIT_FULL)) == 1);
    PRINT_PORT->DataRead = c;
}

RAMFUNC void mic_power_port_init(void)
{
    PINCTRL_SetPadMux(MIC_POWER_PIN, IO_SOURCE_GPIO);
    PINCTRL_SetDriveStrength(MIC_POWER_PIN, PINCTRL_DRIVE_12mA);
    PINCTRL_Pull(MIC_POWER_PIN, PINCTRL_PULL_DISABLE);
    GIO_SetDirection(MIC_POWER_PIN, GIO_DIR_OUTPUT);
    GIO_WriteValue(MIC_POWER_PIN, 0);

    return;
}

RAMFUNC void m_setup_peripherals(void)
{
    m_set_reg_bit(APB_SYSCTRL->CguCfg + 3, 1, 17); //SYSCTRL_ClearClkGate(SYSCTRL_ITEM_APB_UART0);
    m_set_reg_bit(APB_SYSCTRL->CguCfg + 5, 1, 4);

    m_set_reg_bit(APB_SYSCTRL->CguCfg + 3, 1, 1); // case SYSCTRL_ITEM_APB_WDT       :
    m_set_reg_bit(APB_SYSCTRL->CguCfg + 5, 1, 17);

    m_set_reg_bit(APB_SYSCTRL->CguCfg + 3, 1, 6); // case SYSCTRL_ITEM_APB_PinCtrl   :

    m_set_reg_bit(APB_SYSCTRL->CguCfg + 3, 1, 21); // case SYSCTRL_ITEM_APB_GPIO0:
    m_set_reg_bit(APB_SYSCTRL->CguCfg + 5, 1, 18);

    m_set_reg_bit(APB_SYSCTRL->CguCfg + 3, 1, 22); // case SYSCTRL_ITEM_APB_GPIO1:
    m_set_reg_bit(APB_SYSCTRL->CguCfg + 5, 1, 18);

    m_config_uart(24000000, 921600);
    mic_power_port_init();
}

RAMFUNC static void m_GIO_MaskedWrite(volatile uint32_t *reg, const uint8_t index, const uint8_t v)
{
    uint32_t mask = 1 << index;
    *reg = (*reg & (~mask)) | (v << index);
}

RAMFUNC static void m_GIO_EnableRetentionGroupA(uint8_t enable)
{
    #define AON1_REG4       (AON1_CTRL_BASE + 0x10)
    #define AON2_STATUS0    (AON2_CTRL_BASE + 0x100)

    m_GIO_MaskedWrite((volatile uint32_t *)AON1_REG4, 7, enable);
    while (((io_read(AON2_STATUS0) >> 19) & 1) != enable);
}

RAMFUNC static void m_GIO_EnableRetentionGroupB(uint8_t enable)
{
    #define AON2_SLEEP_CTRL     (AON2_CTRL_BASE + 0x1A8)
    #define nop(n) do { int i = n; while (i--) __NOP(); } while (0)
    if (enable)
    {
        m_GIO_MaskedWrite((volatile uint32_t *)AON2_SLEEP_CTRL, 14, 1);
        nop(10);
        m_GIO_MaskedWrite((volatile uint32_t *)AON2_SLEEP_CTRL, 15, 1);
        nop(10);
    }
    else
    {
        m_GIO_MaskedWrite((volatile uint32_t *)AON2_SLEEP_CTRL, 15, 0);
        nop(10);
        m_GIO_MaskedWrite((volatile uint32_t *)AON2_SLEEP_CTRL, 14, 0);
        nop(10);
    }
}

RAMFUNC uint8_t m_SYSCTRL_GetLastWakeupSource(SYSCTRL_WakeupSource_t *source)
{
    source->other = 0;
    source->gpio = APB_SYSCTRL->SysIoWkSource;
    uint32_t a = APB_SYSCTRL->SysIoStatus >> 16;
    if ((source->gpio == 0) && (a == 0))
    {
        a = io_read(AON2_CTRL_BASE + 0x140);
        switch (a & 3)
        {
        case 0:
            return 0;
        case 1:
            source->other |= SYSCTRL_WAKEUP_SOURCE_AUTO;
            break;
        case 3:
            source->other |= SYSCTRL_WAKEUP_SOURCE_AUTO; // fall through
        case 2:
            a >>= 2;
            source->gpio = a & 1;
            source->gpio |= (a & (0x3 << 1)) << (5 - 1);
            source->gpio |= (a & (0x7 << 3)) << (21 - 3);
            source->gpio |= ((uint64_t)(a & (0x3 << 5))) << (36 - 5);
            break;
        default:
            break;
        }

        return 1;
    }

    source->gpio |= ((uint64_t)(a & 0x3f)) << 32;
    if (a & (1 << (6 + 0)))
        source->other |= SYSCTRL_WAKEUP_SOURCE_RTC_ALARM;
    if (a & (1 << (6 + 1)))
        source->other |= SYSCTRL_WAKEUP_SOURCE_AUTO;
    if (a & (1 << (6 + 2)))
        source->other |= SYSCTRL_WAKEUP_SOURCE_COMPARATOR;

    return 1;
}

RAMFUNC uint32_t m_on_deep_sleep_wakeup(const platform_wakeup_call_info_t *info, void *user_data)
{
    SYSCTRL_WakeupSource_t source = {0};
    uint8_t ret;

    m_GIO_EnableRetentionGroupB(0);
    m_GIO_EnableRetentionGroupA(0);
    ret = m_SYSCTRL_GetLastWakeupSource(&source);
    m_setup_peripherals();
    // dbg_printf("[>d:wk]: reason %d source %d\r\n", info->reason, ret);

    if (PLATFORM_WAKEUP_REASON_NORMAL == info->reason) {
        if (ret == 1) {
            if (source.gpio != 0) {
                uint32_t gpio_read_data_h = (source.gpio >> 32) & 0xFFFFFFFF;
                uint32_t gpio_read_data_l = source.gpio & 0xFFFFFFFF;
                log_printf("[wk]: gpio:0x%08x%08x\r\n", gpio_read_data_h, gpio_read_data_l);
                low_power_exit_saving(LOW_POWER_EXIT_REASON_GPIO);
                return 1;
            }
        }
    }

    key_board_start_int_trig();
    return 1;
}

RAMFUNC void m_SYSCTRL_EnableWakeupSourceDetection(void)
{
    m_set_reg_bit((volatile uint32_t *)(AON2_CTRL_BASE + 0x1A8), 1, 16);
}

void vr_system_before_sleep(void);
RAMFUNC uint32_t m_query_deep_sleep_allowed(void *dummy, void *user_data)
{
    (void)(dummy);
    (void)(user_data);

    vr_system_before_sleep();

    m_GIO_EnableRetentionGroupB(1);
    m_GIO_EnableRetentionGroupA(1);
    m_SYSCTRL_EnableWakeupSourceDetection();
    return PLATFORM_ALLOW_DEEP_SLEEP;
}

static uint32_t g_sys_work_status_bits = 0;

static void low_power_start_timer(void);
static void low_power_stop_timer(void);

void low_power_enter_saving(void)
{
    g_exit_saving = 0;
    low_power_stop_timer();
    log_printf("[>i:lp]: enter******************************************\r\n");
    platform_config(PLATFORM_CFG_POWER_SAVING, PLATFORM_CFG_ENABLE);
}

static uint8_t low_power_try_enter_cnt = 0;
static void low_power_try_enter_saving(void)
{
    low_power_try_enter_cnt++;
    if (low_power_try_enter_cnt <= 6) {
        return;
    }

    log_printf("[>i:lp]: working 0x%x %d\r\n", g_sys_work_status_bits, low_power_try_enter_cnt);
    if (g_sys_work_status_bits != 0) {
        if (low_power_try_enter_cnt <= 30) {
            low_power_start_timer();
            return;
        } else {
            g_sys_work_status_bits = 0;
        }
    }

    update_connection_parameter();

    return;
}

static void enter_low_power_timer_callback(TimerHandle_t xTimer)
{
    TMR_WatchDogRestart();
    low_power_try_enter_saving();
    return;
}

static TaskHandle_t low_power_task_handler;
static SemaphoreHandle_t low_power_task_BinarySemaphore;
static void low_power_task(void *pvParameters)
{
    while(1) {
        BaseType_t r = xSemaphoreTake(low_power_task_BinarySemaphore, portMAX_DELAY);
        if (pdTRUE != r) {
            continue;
        }
        log_printf("[>i:lp]: exit\r\n");
        platform_config(PLATFORM_CFG_POWER_SAVING, PLATFORM_CFG_DISABLE);
        low_power_start_timer();
    }
}

static BaseType_t xHigherPriorityTaskWoken = pdFALSE;
static uint8_t low_power_timer_is_run = 0;
static void low_power_start_timer(void)
{
    if (low_power_timer_is_run) {
        return;
    }
    xTimerStartFromISR(enter_low_power_timer, &xHigherPriorityTaskWoken);
    low_power_timer_is_run = 1;
    return;
}

static void low_power_stop_timer(void)
{
    if (!low_power_timer_is_run) {
        return;
    }
    xTimerStopFromISR(enter_low_power_timer, &xHigherPriorityTaskWoken);
    low_power_timer_is_run = 0;
    return;
}

void app_setup_peripherals(void);
void low_power_exit_saving(low_power_exit_reason_t reason)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    static low_power_exit_reason_t last_reason = LOW_POWER_EXIT_REASON_MAX;

    if (last_reason != reason) {
        g_sys_work_status_bits = (g_sys_work_status_bits | (0x1 << reason));
        last_reason = reason;
    }
    low_power_try_enter_cnt = 0;

    if (g_exit_saving) {
        return;
    }

    g_exit_saving = 1;

    app_setup_peripherals();
    xSemaphoreGiveFromISR(low_power_task_BinarySemaphore, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    return;
}

void low_power_clear_exit_reason(low_power_exit_reason_t reason)
{
    g_sys_work_status_bits = (g_sys_work_status_bits & (~(0x1 << reason)));
    low_power_try_enter_cnt = 0;
    return;
}

void low_power_create_timer(void)
{
    enter_low_power_timer = xTimerCreate("enter low power",
                        pdMS_TO_TICKS(1000 * 1),
                        pdTRUE,
                        NULL,
                        enter_low_power_timer_callback);

    low_power_task_BinarySemaphore = xSemaphoreCreateBinary();
    xTaskCreate((TaskFunction_t)low_power_task,
               "key",
               configMINIMAL_STACK_SIZE,
               NULL,
               (configMAX_PRIORITIES - configMAX_PRIORITIES + 5),
               (TaskHandle_t*)&low_power_task_handler);

    low_power_start_timer();
    return;
}

#if defined __cplusplus
    }
#endif
